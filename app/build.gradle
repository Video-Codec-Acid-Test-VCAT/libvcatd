/*
* VCAT (Video Codec Acid Test)
* (license header unchanged)
*/

import org.gradle.internal.os.OperatingSystem

plugins {
    id 'com.android.library'
    id 'maven-publish'
    id 'signing'
}

group   = 'com.roncatech.vcat'
def baseVersion = '0.1.0.3'
def localSuffix = (findProperty('localVersionSuffix') ?: '')
version = baseVersion + localSuffix   // e.g. -PlocalVersionSuffix=-local

def abis      = ['arm64-v8a','armeabi-v7a']
// vvdec: build ONLY arm64. (32-bit vvdec is not supported/needed in this project)
def vvdecAbis = ['arm64-v8a']
def minApi    = 29

android {
    namespace 'com.roncatech.libvcat'
    compileSdk 35
    ndkVersion "27.0.12077973"

    defaultConfig {
        minSdk minApi
        targetSdk 35
        ndk { abiFilters.addAll(abis) }

        // CMake gets per-ABI install dirs for dav1d and vvdec
        externalNativeBuild {
            cmake {
                arguments "-DDAV1D_INSTALL_ARM64_V8A=${layout.buildDirectory.dir('dav1d/install-arm64-v8a').get().asFile.absolutePath}",
                        "-DDAV1D_INSTALL_ARMEABI_V7A=${layout.buildDirectory.dir('dav1d/install-armeabi-v7a').get().asFile.absolutePath}",
                        "-DVVDEC_INSTALL_ARM64_V8A=${layout.buildDirectory.dir('vvdec/install-arm64-v8a').get().asFile.absolutePath}"
                // IMPORTANT: do NOT pass VVDEC_INSTALL_ARMEABI_V7A; we don't build vvdec for 32-bit.
            }
        }

        consumerProguardFiles 'consumer-rules.pro'
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug { debuggable true }
    }

    externalNativeBuild { cmake { path file('src/main/cpp/CMakeLists.txt') } }

    // By default, publish only release. Enable all variants with -PpublishAllVariants=true
    def publishAll = (findProperty('publishAllVariants') ?: 'false').toBoolean()
    publishing {
        if (publishAll) {
            multipleVariants {
                allVariants()
                withSourcesJar()
            }
        } else {
            singleVariant("release") { withSourcesJar() }
        }
    }

    sourceSets {
        main {
            jniLibs.srcDirs 'src/main/jniLibs'
            resources.srcDirs 'src/main/resources'
        }
    }
}

/* =============================================================================
 * Tooling (Option A): Use Android SDK CMake/Ninja + project-local Meson via Python
 * ============================================================================= */

def os = OperatingSystem.current()
def isWindows = os.isWindows()
def exe = { String n -> isWindows ? "${n}.exe" : n }
def cmdExt = isWindows ? ".cmd" : ""

// Allow overrides:
//   -Ppython=/path/to/python
//   -Pcmake=/path/to/cmake
//   -Pninja=/path/to/ninja
def pythonCmd = (findProperty("python") ?: (isWindows ? "python" : "python3")) as String

// Find highest installed Android SDK CMake version under $SDK/cmake/<ver>/bin
def compareVersions = { String a, String b ->
    def pa = a.tokenize('.-').collect { it.isInteger() ? it.toInteger() : 0 }
    def pb = b.tokenize('.-').collect { it.isInteger() ? it.toInteger() : 0 }
    def n = Math.max(pa.size(), pb.size())
    for (int i=0; i<n; i++) {
        def va = (i < pa.size()) ? pa[i] : 0
        def vb = (i < pb.size()) ? pb[i] : 0
        if (va != vb) return va <=> vb
    }
    return 0
}

def sdkDir = android.sdkDirectory
def cmakeBinDirProvider = providers.provider {
    def cmakeRoot = new File(sdkDir, "cmake")
    if (!cmakeRoot.exists()) return null
    def vers = cmakeRoot.listFiles()?.findAll { it.isDirectory() && new File(it, "bin").isDirectory() } ?: []
    if (vers.isEmpty()) return null
    vers.sort { x, y -> compareVersions(x.name, y.name) }
    def best = vers.last()
    def bin = new File(best, "bin")
    return bin.exists() ? bin : null
}

def cmakeCmd = (findProperty("cmake") ?: providers.provider {
    def bin = cmakeBinDirProvider.getOrNull()
    return bin ? new File(bin, exe("cmake")).absolutePath : null
}.getOrNull()) as String

def ninjaCmd = (findProperty("ninja") ?: providers.provider {
    def bin = cmakeBinDirProvider.getOrNull()
    return bin ? new File(bin, exe("ninja")).absolutePath : null
}.getOrNull()) as String

def requireSdkCmake = {
    if (!cmakeCmd || !file(cmakeCmd).exists()) {
        throw new GradleException(
                "CMake not found in Android SDK.\n" +
                        "Install it via Android Studio → SDK Manager → SDK Tools → CMake,\n" +
                        "or pass -Pcmake=/absolute/path/to/cmake"
        )
    }
    if (!ninjaCmd || !file(ninjaCmd).exists()) {
        throw new GradleException(
                "Ninja not found (normally bundled with Android SDK CMake).\n" +
                        "Install CMake via SDK Manager or pass -Pninja=/absolute/path/to/ninja"
        )
    }
}

def hostPythonPkgsDir = layout.buildDirectory.dir("host-python-pkgs").get().asFile

tasks.register("ensureMeson") {
    outputs.dir(hostPythonPkgsDir)
    doLast {
        hostPythonPkgsDir.mkdirs()
        exec {
            commandLine pythonCmd, "-m", "pip", "install", "--upgrade",
                    "--target", hostPythonPkgsDir.absolutePath,
                    "meson"
        }
    }
}

def mesonModuleCommandLine = { List<String> args ->
    [pythonCmd, "-m", "mesonbuild.mesonmain"] + args
}

def withMesonEnv = { spec ->
    def pyPath = hostPythonPkgsDir.absolutePath + File.pathSeparator + (System.getenv("PYTHONPATH") ?: "")
    spec.environment "PYTHONPATH", pyPath

    // Meson invokes "ninja" by name; ensure SDK ninja is on PATH
    def cmBin = cmakeBinDirProvider.getOrNull()
    if (cmBin != null) {
        def path = cmBin.absolutePath + File.pathSeparator + (System.getenv("PATH") ?: "")
        spec.environment "PATH", path
    }
}

/* ===== dav1d build (Meson/Ninja) ===== */

def ndkDirProvider  = providers.provider { android.ndkDirectory?.absolutePath }
def hostTagProvider = providers.provider {
    def ndk = ndkDirProvider.getOrNull()
    if (!ndk) return null
    def tags = ['darwin-arm64','darwin-x86_64','linux-x86_64','windows-x86_64']
    return tags.find { tag -> file("${ndk}/toolchains/llvm/prebuilt/${tag}/bin").exists() }
}

def triplet = { abi -> abi == 'arm64-v8a' ? 'aarch64-linux-android' : 'armv7a-linux-androideabi' }
def ccFor   = { abi, ndk, tag -> "${ndk}/toolchains/llvm/prebuilt/${tag}/bin/${triplet(abi)}${minApi}-clang${cmdExt}" }
def cxxFor  = { abi, ndk, tag -> "${ndk}/toolchains/llvm/prebuilt/${tag}/bin/${triplet(abi)}${minApi}-clang++${cmdExt}" }

def dav1dWorkRoot = layout.buildDirectory.dir('dav1d').get().asFile
def dav1dSrcDir   = new File(dav1dWorkRoot, 'src')
def dav1dRef      = (findProperty('dav1dRef') ?: '1.5.1') as String
def dav1dRemote   = (findProperty('dav1dRemote') ?: 'https://code.videolan.org/videolan/dav1d.git') as String
def dav1dLocal    = (findProperty('DAV1D_SRC') ?: System.getenv('DAV1D_SRC')) as String

tasks.register('fetchDav1d') {
    outputs.dir(dav1dSrcDir)
    doLast {
        dav1dWorkRoot.mkdirs()

        if (dav1dLocal) {
            delete dav1dSrcDir
            copy { from dav1dLocal; into dav1dSrcDir; exclude '.git' }
            return
        }
        def clearGitEnv = { spec -> spec.environment.remove('GIT_DIR'); spec.environment.remove('GIT_WORK_TREE') }

        if (!dav1dSrcDir.exists()) {
            exec { workingDir dav1dWorkRoot; clearGitEnv(delegate)
                commandLine 'git','clone','--depth','1','--branch', dav1dRef, dav1dRemote,'src' }
        } else if (!new File(dav1dSrcDir,'.git').exists()) {
            delete dav1dSrcDir
            exec { workingDir dav1dWorkRoot; clearGitEnv(delegate)
                commandLine 'git','clone','--depth','1','--branch', dav1dRef, dav1dRemote,'src' }
        } else {
            exec { workingDir dav1dSrcDir; clearGitEnv(delegate); commandLine 'git','fetch','--depth','1','origin', dav1dRef }
            exec { workingDir dav1dSrcDir; clearGitEnv(delegate); commandLine 'git','checkout','-f', dav1dRef }
            exec { workingDir dav1dSrcDir; clearGitEnv(delegate); commandLine 'git','reset','--hard','FETCH_HEAD' }
        }
    }
}

tasks.register('cleanDav1d') { doLast { delete dav1dWorkRoot } }

abis.each { abi ->
    def crossFile  = layout.buildDirectory.file("dav1d/toolchains/meson-${abi}.ini").get().asFile
    def buildDir   = new File(dav1dWorkRoot, "build-${abi}")
    def installDir = new File(dav1dWorkRoot, "install-${abi}")

    tasks.register("genCrossFile_${abi}") {
        dependsOn 'fetchDav1d'
        outputs.file(crossFile)
        doLast {
            def ndk = ndkDirProvider.getOrNull()
            def tag = hostTagProvider.getOrNull()
            if (!ndk || !tag) {
                throw new GradleException(
                        "NDK toolchain not found. Ensure ndkVersion ${android.ndkVersion} is installed " +
                                "and that a matching host toolchain directory exists under " +
                                "${android.ndkDirectory}/toolchains/llvm/prebuilt/."
                )
            }

            crossFile.parentFile.mkdirs()
            crossFile.text = """
[binaries]
c = '${ccFor(abi, ndk, tag)}'
cpp = '${cxxFor(abi, ndk, tag)}'
ar = '${ndk}/toolchains/llvm/prebuilt/${tag}/bin/llvm-ar${isWindows ? ".exe" : ""}'
strip = '${ndk}/toolchains/llvm/prebuilt/${tag}/bin/llvm-strip${isWindows ? ".exe" : ""}'
pkg-config = 'false'

[built-in options]
c_std = 'c11'
cpp_std = 'c++17'
werror = false
default_library = 'static'

[host_machine]
system = 'android'
cpu_family = '${abi == 'arm64-v8a' ? 'aarch64' : 'arm'}'
cpu = '${abi == 'arm64-v8a' ? 'armv8' : 'armv7'}'
endian = 'little'
""".stripIndent()
        }
    }

    tasks.register("buildDav1d_${abi}") {
        dependsOn "genCrossFile_${abi}", "ensureMeson"
        outputs.dir(installDir)
        doLast {
            requireSdkCmake()

            buildDir.mkdirs(); installDir.mkdirs()

            exec {
                workingDir buildDir
                withMesonEnv(delegate)
                commandLine mesonModuleCommandLine([
                        'setup', '.', dav1dSrcDir.absolutePath,
                        '--cross-file', crossFile.absolutePath,
                        '-Ddefault_library=static',
                        '-Denable_asm=true',
                        '-Denable_tests=false',
                        '-Dbuildtype=release',
                        '--prefix', installDir.absolutePath
                ])
            }

            exec { workingDir buildDir; withMesonEnv(delegate); commandLine ninjaCmd }
            exec { workingDir buildDir; withMesonEnv(delegate); commandLine ninjaCmd, 'install' }
        }
    }
}

/* ===== vvdec via git @ v3.0.0 (CMake/Ninja) ===== */

def vvdecWorkRoot = layout.buildDirectory.dir('vvdec').get().asFile
def vvdecSrcDir   = new File(vvdecWorkRoot, 'src')

def vvdecRef    = (findProperty('vvdecRef') ?: 'v3.0.0') as String
def vvdecRemote = (findProperty('vvdecRemote') ?: 'https://github.com/fraunhoferhhi/vvdec.git') as String
def vvdecLocal  = (findProperty('VVDEC_SRC') ?: System.getenv('VVDEC_SRC')) as String

tasks.register('fetchVvdec') {
    outputs.dir(vvdecSrcDir)
    doLast {
        vvdecWorkRoot.mkdirs()

        if (vvdecLocal) {
            delete vvdecSrcDir
            copy { from vvdecLocal; into vvdecSrcDir; exclude '.git' }
            return
        }
        def clearGitEnv = { s -> s.environment.remove('GIT_DIR'); s.environment.remove('GIT_WORK_TREE') }

        if (!vvdecSrcDir.exists()) {
            exec { workingDir vvdecWorkRoot; clearGitEnv(delegate)
                commandLine 'git','clone','--depth','1','--branch', vvdecRef, vvdecRemote,'src' }
        } else if (!new File(vvdecSrcDir,'.git').exists()) {
            delete vvdecSrcDir
            exec { workingDir vvdecWorkRoot; clearGitEnv(delegate)
                commandLine 'git','clone','--depth','1','--branch', vvdecRef, vvdecRemote,'src' }
        } else {
            exec { workingDir vvdecSrcDir; clearGitEnv(delegate); commandLine 'git','fetch','--depth','1','origin', vvdecRef }
            exec { workingDir vvdecSrcDir; clearGitEnv(delegate); commandLine 'git','checkout','-f', vvdecRef }
            exec { workingDir vvdecSrcDir; clearGitEnv(delegate); commandLine 'git','reset','--hard','FETCH_HEAD' }
        }
    }
}

vvdecAbis.each { abi ->
    def buildDir   = new File(vvdecWorkRoot, "build-${abi}")
    def installDir = new File(vvdecWorkRoot, "install-${abi}")

    tasks.register("buildVvdec_${abi}") {
        dependsOn 'fetchVvdec'
        outputs.dir(installDir)
        doLast {
            requireSdkCmake()

            buildDir.mkdirs(); installDir.mkdirs()
            def ndk = android.ndkDirectory?.absolutePath
            if (!ndk) throw new GradleException("NDK not found. Ensure ndkVersion ${android.ndkVersion} is installed.")

            exec {
                workingDir buildDir
                commandLine cmakeCmd,
                        '-G','Ninja',
                        "-D","CMAKE_MAKE_PROGRAM=${ninjaCmd}",
                        "-D","CMAKE_TOOLCHAIN_FILE=${ndk}/build/cmake/android.toolchain.cmake",
                        "-D","ANDROID_ABI=${abi}",
                        "-D","ANDROID_PLATFORM=android-${minApi}",
                        "-D","CMAKE_BUILD_TYPE=Release",
                        "-D","BUILD_SHARED_LIBS=OFF",
                        "-D","VVDEC_ENABLE_TRACING=OFF",

                        // Critical: don't build vvdecapp / examples / tests when cross-compiling
                        "-D","VVDEC_BUILD_APPS=OFF",
                        "-D","VVDEC_BUILD_EXAMPLES=OFF",
                        "-D","VVDEC_BUILD_TESTS=OFF",
                        "-D","BUILD_TESTING=OFF",

                        "-D","CMAKE_INSTALL_PREFIX=${installDir.absolutePath}",
                        vvdecSrcDir.absolutePath
            }
            exec { workingDir buildDir; commandLine ninjaCmd }
            exec { workingDir buildDir; commandLine ninjaCmd, 'install' }
        }
    }
}

/* ===== Ensure native deps exist before JNI configure ===== */

tasks.named('preBuild').configure {
    dependsOn abis.collect { "buildDav1d_${it}" } +
            vvdecAbis.collect { "buildVvdec_${it}" }
}

/* ===== Publishing (local-friendly) ===== */

// Minimal javadoc jar (OK for local / Central component validation)
tasks.register('androidJavadocJar', Jar) { archiveClassifier = 'javadoc' }

publishing {
    publications {
        create('mavenRelease', MavenPublication) {
            groupId    = project.group
            artifactId = 'libvcat'
            version    = project.version

            afterEvaluate {
                from(components.getByName('release'))
            }

            artifact(tasks.named('androidJavadocJar'))

            pom {
                name.set('VCAT libvcat')
                description.set('Video Codec Acid Test core library (pre-release)')
                url.set('https://roncatech.com')
                licenses {
                    license {
                        name.set('GPL-3.0-or-later')
                        url.set('https://www.gnu.org/licenses/gpl-3.0.html')
                        distribution.set('repo')
                    }
                }
                scm {
                    url.set('https://github.com/jonathannah/vcat')
                    connection.set('scm:git:https://github.com/jonathannah/vcat.git')
                    developerConnection.set('scm:git:ssh://git@github.com/jonathannah/vcat.git')
                }
                developers { developer { id.set('roncatech'); name.set('RoncaTech LLC') } }
            }
        }
    }
    // No repositories{} needed for publishToMavenLocal
}

// Make signing optional and opt-in
def haveSigningKeys = (findProperty('signing.gnupg.keyName') ?: '') as String
def signRelease     = (findProperty('signRelease') ?: 'false').toBoolean()

signing {
    required { signRelease && !haveSigningKeys.isEmpty() }
    if (haveSigningKeys && signRelease) {
        useGpgCmd()
        sign publishing.publications['mavenRelease']
    }
}

// Convenience: publish to m2 then print coordinates
tasks.register('publishLocal') {
    dependsOn 'publishToMavenLocal'
    doLast {
        println "Published: ~/.m2/repository/com/roncatech/vcat/libvcat/${project.version}/libvcat-${project.version}.aar"
    }
}

/* ===== Auto-publish to MavenLocal after common Android Studio builds =====
 *
 * Android Studio typically runs assembleDebug / assemble / build.
 * We finalize those tasks with publishToMavenLocal so ~/.m2 stays up-to-date.
 *
 * Disable with: -PautoPublishMavenLocal=false
 */
def autoPublishMavenLocal = (findProperty('autoPublishMavenLocal') ?: 'true').toBoolean()
if (autoPublishMavenLocal) {
    def publishM2 = tasks.named("publishToMavenLocal")
    tasks.matching { t ->
        t.name in ["assemble", "build", "assembleDebug", "bundleDebugAar", "bundleReleaseAar"]
    }.configureEach { t ->
        t.finalizedBy(publishM2)
    }
}

/* ===== Dependencies ===== */
def media3Version = "1.8.0"

dependencies {
    compileOnly "androidx.annotation:annotation:1.7.1"
    compileOnly "androidx.media3:media3-exoplayer:$media3Version"

    implementation "org.checkerframework:checker-compat-qual:2.5.5"
    implementation "com.google.guava:guava:32.1.3-android"

    testImplementation 'junit:junit:4.13.2'
    testImplementation "androidx.media3:media3-exoplayer:$media3Version"
}
