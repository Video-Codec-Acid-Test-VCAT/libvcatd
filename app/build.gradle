/*
* VCAT (Video Codec Acid Test)
* (license header unchanged)
*/

plugins {
    id 'com.android.library'
    id 'maven-publish'
    id 'signing'
}

group   = 'com.roncatech.vcat'
def baseVersion = '0.1.0.0'
def localSuffix = (findProperty('localVersionSuffix') ?: '')
version = baseVersion + localSuffix   // e.g. -PlocalVersionSuffix=-local

def abis      = ['arm64-v8a','armeabi-v7a']
def vvdecAbis = ['arm64-v8a','armeabi-v7a']          // vvdec arm64 only
def minApi    = 29

android {
    namespace 'com.roncatech.libvcat'
    compileSdk 35
    ndkVersion "27.0.12077973"

    defaultConfig {
        minSdk minApi
        targetSdk 35
        ndk { abiFilters.addAll(abis) }

        // CMake gets per-ABI install dirs for dav1d and vvdec
        externalNativeBuild {
            cmake {
                arguments "-DDAV1D_INSTALL_ARM64_V8A=${layout.buildDirectory.dir('dav1d/install-arm64-v8a').get().asFile.absolutePath}",
                        "-DDAV1D_INSTALL_ARMEABI_V7A=${layout.buildDirectory.dir('dav1d/install-armeabi-v7a').get().asFile.absolutePath}",
                        "-DVVDEC_INSTALL_ARM64_V8A=${layout.buildDirectory.dir('vvdec/install-arm64-v8a').get().asFile.absolutePath}",
                        "-DVVDEC_INSTALL_ARMEABI_V7A=${layout.buildDirectory.dir('vvdec/install-armeabi-v7a').get().asFile.absolutePath}"
            }
        }

        consumerProguardFiles 'consumer-rules.pro'
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug { debuggable true }
    }

    externalNativeBuild { cmake { path file('src/main/cpp/CMakeLists.txt') } }

    // By default, publish only release. Enable all variants with -PpublishAllVariants=true
    def publishAll = (findProperty('publishAllVariants') ?: 'false').toBoolean()
    publishing {
        if (publishAll) {
            multipleVariants {
                allVariants()
                withSourcesJar()
            }
        } else {
            singleVariant("release") { withSourcesJar() }
        }
    }

    sourceSets {
        main {
            jniLibs.srcDirs 'src/main/jniLibs'
            resources.srcDirs 'src/main/resources'
        }
    }
}

/* ===== dav1d build (Meson/Ninja) ===== */

def ndkDirProvider  = providers.provider { android.ndkDirectory?.absolutePath }
// Add Windows host tag and avoid hard failure on null
def hostTagProvider = providers.provider {
    def ndk = ndkDirProvider.getOrNull()
    if (!ndk) return null

    // Known NDK host tags
    def tags = ['darwin-arm64','darwin-x86_64','linux-x86_64','windows-x86_64']

    return tags.find { tag ->
        file("${ndk}/toolchains/llvm/prebuilt/${tag}/bin").exists()
    }
}

// Cross-platform command suffixes
def isWindows = System.getProperty("os.name").toLowerCase().contains("windows")
def cmdExt  = isWindows ? ".cmd" : ""
def exeExt  = isWindows ? ".exe" : ""
def mesonCmd = isWindows ? "meson.exe" : "meson"

def triplet = { abi -> abi == 'arm64-v8a' ? 'aarch64-linux-android' : 'armv7a-linux-androideabi' }
def ccFor   = { abi, ndk, tag -> "${ndk}/toolchains/llvm/prebuilt/${tag}/bin/${triplet(abi)}${minApi}-clang${cmdExt}" }
def cxxFor  = { abi, ndk, tag -> "${ndk}/toolchains/llvm/prebuilt/${tag}/bin/${triplet(abi)}${minApi}-clang++${cmdExt}" }
def arFor   = { ndk, tag -> "${ndk}/toolchains/llvm/prebuilt/${tag}/bin/llvm-ar${exeExt}" }
def stripFor = { ndk, tag -> "${ndk}/toolchains/llvm/prebuilt/${tag}/bin/llvm-strip${exeExt}" }

def dav1dWorkRoot = layout.buildDirectory.dir('dav1d').get().asFile
def dav1dSrcDir   = new File(dav1dWorkRoot, 'src')
def dav1dRef      = (findProperty('dav1dRef') ?: '1.5.1') as String
def dav1dRemote   = (findProperty('dav1dRemote') ?: 'https://code.videolan.org/videolan/dav1d.git') as String
def dav1dLocal    = (findProperty('DAV1D_SRC') ?: System.getenv('DAV1D_SRC')) as String // optional override

tasks.register('fetchDav1d') {
    outputs.dir(dav1dSrcDir)
    doLast {
        dav1dWorkRoot.mkdirs()

        if (dav1dLocal) {
            delete dav1dSrcDir
            copy { from dav1dLocal; into dav1dSrcDir; exclude '.git' }
            return
        }
        def clearGitEnv = { spec -> spec.environment.remove('GIT_DIR'); spec.environment.remove('GIT_WORK_TREE') }

        if (!dav1dSrcDir.exists()) {
            exec { workingDir dav1dWorkRoot; clearGitEnv(delegate)
                commandLine 'git','clone','--depth','1','--branch', dav1dRef, dav1dRemote,'src' }
        } else if (!new File(dav1dSrcDir,'.git').exists()) {
            delete dav1dSrcDir
            exec { workingDir dav1dWorkRoot; clearGitEnv(delegate)
                commandLine 'git','clone','--depth','1','--branch', dav1dRef, dav1dRemote,'src' }
        } else {
            exec { workingDir dav1dSrcDir; clearGitEnv(delegate); commandLine 'git','fetch','--depth','1','origin', dav1dRef }
            exec { workingDir dav1dSrcDir; clearGitEnv(delegate); commandLine 'git','checkout','-f', dav1dRef }
            exec { workingDir dav1dSrcDir; clearGitEnv(delegate); commandLine 'git','reset','--hard','FETCH_HEAD' }
        }
    }
}

tasks.register('cleanDav1d') { doLast { delete dav1dWorkRoot } }

abis.each { abi ->
    def crossFile  = layout.buildDirectory.file("dav1d/toolchains/meson-${abi}.ini").get().asFile
    def buildDir   = new File(dav1dWorkRoot, "build-${abi}")
    def installDir = new File(dav1dWorkRoot, "install-${abi}")

    tasks.register("genCrossFile_${abi}") {
        dependsOn 'fetchDav1d'
        outputs.file(crossFile)
        doLast {
            def ndk = ndkDirProvider.getOrNull()
            def tag = hostTagProvider.getOrNull()
            if (!ndk || !tag) {
                throw new GradleException(
                        "NDK toolchain not found. Ensure ndkVersion ${android.ndkVersion} is installed " +
                                "and that a matching host toolchain directory exists under " +
                                "${android.ndkDirectory}/toolchains/llvm/prebuilt/."
                )
            }

            crossFile.parentFile.mkdirs()
            crossFile.text = """
[binaries]
c = '${ccFor(abi, ndk, tag)}'
cpp = '${cxxFor(abi, ndk, tag)}'
ar = '${arFor(ndk, tag)}'
strip = '${stripFor(ndk, tag)}'
pkg-config = 'false'

[built-in options]
c_std = 'c11'
cpp_std = 'c++17'
werror = false
default_library = 'static'

[host_machine]
system = 'android'
cpu_family = '${abi == 'arm64-v8a' ? 'aarch64' : 'arm'}'
cpu = '${abi == 'arm64-v8a' ? 'armv8' : 'armv7'}'
endian = 'little'
""".stripIndent()
        }
    }

    tasks.register("buildDav1d_${abi}") {
        dependsOn "genCrossFile_${abi}"
        outputs.dir(installDir)
        doLast {
            buildDir.mkdirs(); installDir.mkdirs()
            exec {
                workingDir buildDir
                commandLine mesonCmd, 'setup', '.', dav1dSrcDir.absolutePath,
                        '--cross-file', crossFile.absolutePath,
                        '-Ddefault_library=static','-Denable_asm=true',
                        '-Denable_tests=false','-Dbuildtype=release',
                        '--prefix', installDir.absolutePath
            }
            exec { workingDir buildDir; commandLine 'ninja' }
            exec { workingDir buildDir; commandLine 'ninja','install' }
        }
    }
}

/* ===== vvdec via git @ v3.0.0 (CMake/Ninja) ===== */

def vvdecWorkRoot = layout.buildDirectory.dir('vvdec').get().asFile
def vvdecSrcDir   = new File(vvdecWorkRoot, 'src')

def vvdecRef    = (findProperty('vvdecRef') ?: 'v3.0.0') as String
def vvdecRemote = (findProperty('vvdecRemote') ?: 'https://github.com/fraunhoferhhi/vvdec.git') as String
def vvdecLocal  = (findProperty('VVDEC_SRC') ?: System.getenv('VVDEC_SRC')) as String

tasks.register('fetchVvdec') {
    outputs.dir(vvdecSrcDir)
    doLast {
        vvdecWorkRoot.mkdirs()

        if (vvdecLocal) {
            delete vvdecSrcDir
            copy { from vvdecLocal; into vvdecSrcDir; exclude '.git' }
            return
        }
        def clearGitEnv = { s -> s.environment.remove('GIT_DIR'); s.environment.remove('GIT_WORK_TREE') }

        if (!vvdecSrcDir.exists()) {
            exec { workingDir vvdecWorkRoot; clearGitEnv(delegate)
                commandLine 'git','clone','--depth','1','--branch', vvdecRef, vvdecRemote,'src' }
        } else if (!new File(vvdecSrcDir,'.git').exists()) {
            delete vvdecSrcDir
            exec { workingDir vvdecWorkRoot; clearGitEnv(delegate)
                commandLine 'git','clone','--depth','1','--branch', vvdecRef, vvdecRemote,'src' }
        } else {
            exec { workingDir vvdecSrcDir; clearGitEnv(delegate); commandLine 'git','fetch','--depth','1','origin', vvdecRef }
            exec { workingDir vvdecSrcDir; clearGitEnv(delegate); commandLine 'git','checkout','-f', vvdecRef }
            exec { workingDir vvdecSrcDir; clearGitEnv(delegate); commandLine 'git','reset','--hard','FETCH_HEAD' }
        }
    }
}

vvdecAbis.each { abi ->
    def buildDir   = new File(vvdecWorkRoot, "build-${abi}")
    def installDir = new File(vvdecWorkRoot, "install-${abi}")

    tasks.register("buildVvdec_${abi}") {
        dependsOn 'fetchVvdec'
        outputs.dir(installDir)
        doLast {
            buildDir.mkdirs(); installDir.mkdirs()
            def ndk = android.ndkDirectory?.absolutePath
            if (!ndk) throw new GradleException("NDK not found. Ensure ndkVersion ${android.ndkVersion} is installed.")

            exec {
                workingDir buildDir
                commandLine 'cmake',
                        '-G','Ninja',
                        "-D","CMAKE_TOOLCHAIN_FILE=${ndk}/build/cmake/android.toolchain.cmake",
                        "-D","ANDROID_ABI=${abi}",
                        "-D","ANDROID_PLATFORM=android-${minApi}",
                        "-D","CMAKE_BUILD_TYPE=Release",
                        "-D","BUILD_SHARED_LIBS=OFF",
                        "-D","VVDEC_ENABLE_TRACING=OFF",
                        "-D","CMAKE_INSTALL_PREFIX=${installDir.absolutePath}",
                        vvdecSrcDir.absolutePath
            }
            exec { workingDir buildDir; commandLine 'ninja' }
            exec { workingDir buildDir; commandLine 'ninja','install' }
        }
    }
}

/* ===== Ensure native deps exist before JNI configure ===== */

tasks.named('preBuild').configure {
    dependsOn abis.collect { "buildDav1d_${it}" } +
            vvdecAbis.collect { "buildVvdec_${it}" }
}

/* ===== Publishing (local-friendly) ===== */

// Minimal javadoc jar (OK for local / Central component validation)
tasks.register('androidJavadocJar', Jar) { archiveClassifier = 'javadoc' }

publishing {
    publications {
        create('mavenRelease', MavenPublication) {
            groupId    = project.group
            artifactId = 'libvcat'
            version    = project.version

            // Map Android variants into publications.
            afterEvaluate {
                def publishAll = (findProperty('publishAllVariants') ?: 'false').toBoolean()
                if (publishAll) {
                    from(components.getByName('release'))
                    if (components.findByName('debug') != null) {
                        // Optional: also create a debug publication if you want it separately.
                        // For simplicity we keep one publication; release AAR is usually enough.
                    }
                } else {
                    from(components.getByName('release'))
                }
            }

            artifact(tasks.named('androidJavadocJar'))

            pom {
                name.set('VCAT libvcat')
                description.set('Video Codec Acid Test core library (pre-release)')
                url.set('https://roncatech.com')
                licenses {
                    license {
                        name.set('GPL-3.0-or-later')
                        url.set('https://www.gnu.org/licenses/gpl-3.0.html')
                        distribution.set('repo')
                    }
                }
                scm {
                    url.set('https://github.com/jonathannah/vcat')
                    connection.set('scm:git:https://github.com/jonathannah/vcat.git')
                    developerConnection.set('scm:git:ssh://git@github.com/jonathannah/vcat.git')
                }
                developers { developer { id.set('roncatech'); name.set('RoncaTech LLC') } }
            }
        }
    }
    // No repositories{} needed for publishToMavenLocal
}

// Make signing optional and opt-in
def haveSigningKeys = (findProperty('signing.gnupg.keyName') ?: '') as String
def signRelease     = (findProperty('signRelease') ?: 'false').toBoolean()

signing {
    required { signRelease && !haveSigningKeys.isEmpty() }
    if (haveSigningKeys && signRelease) {
        useGpgCmd()
        sign publishing.publications['mavenRelease']
    }
}

// Convenience: publish to m2 then print coordinates
tasks.register('publishLocal') {
    dependsOn 'publishToMavenLocal'
    doLast {
        println "Published: ~/.m2/repository/com/roncatech/vcat/libvcat/${project.version}/libvcat-${project.version}.aar"
    }
}

/* ===== Dependencies ===== */
def media3Version = "1.8.0"

dependencies {
    compileOnly "androidx.annotation:annotation:1.7.1"

    // ExoPlayer 2 -> Media3 ExoPlayer
    compileOnly "androidx.media3:media3-exoplayer:$media3Version"

    implementation "org.checkerframework:checker-compat-qual:2.5.5" // provides @NullableType
    implementation "com.google.guava:guava:32.1.3-android"           // AtomParsers uses ImmutableList/Ints

    testImplementation 'junit:junit:4.13.2'
    testImplementation "androidx.media3:media3-exoplayer:$media3Version"
}

